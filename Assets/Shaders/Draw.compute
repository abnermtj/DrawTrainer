#pragma kernel Update
#pragma kernel InitBackground

RWTexture2D<float4> _Canvas;
RWTexture2D<float4> _BrushTexture;
float _CanvasWidth;
float _CanvasHeight;
float4 _PreviousMousePosition;
float4 _MousePosition;
float _StrokeSmoothingInterval;
bool _MouseDown;
float _BrushSize;
float4 _BrushColour;
float4 _BackgroundColour;

float4 CustomBrush(float2 pixelPos, float4 currentColor, float4 brushColor, float brushSize, float2 previousMousePosition,
	float2 mousePosition, float strokeSmoothingInterval)
{
	// TODO implement custom textured brushed
}

float4 RoundBrush(float2 pixelPos, float4 currentColor, float4 brushColor, float brushSize, float2 previousMousePosition,
	float2 mousePosition, float strokeSmoothingInterval)
{
	for (float i = 0; i < 1.0; i += strokeSmoothingInterval)
	{
		float2 mousePos = lerp(previousMousePosition, mousePosition, i);
		// Pixels affected by brush
		if (length(pixelPos - mousePos) < brushSize) {
			float4 finalColor = brushColor;
			//finalColor.w = 1.0f - (length(pixelPos - mousePos) / brushSize); // Too expensve to do per pixel!
			//if (currentColor.w > finalColor.w) {
			//	finalColor.w = currentColor.w;
			//}
			return finalColor;
		}
	}
	// Pixels not affected by brush
	return currentColor;
}

[numthreads(8, 8, 1)]
void InitBackground(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= _CanvasWidth || id.y >= _CanvasHeight)
		return;

	_BackgroundColour.w = 0.0f;
	_Canvas[id.xy] = _BackgroundColour;
}

[numthreads(8, 8, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
	if (!_MouseDown)
		return;

	if (id.x >= _CanvasWidth || id.y >= _CanvasHeight)
		return;

	float4 curBrush = RoundBrush(id.xy, _Canvas[id.xy], _BrushColour, _BrushSize,
		_PreviousMousePosition, _MousePosition, _StrokeSmoothingInterval);
	_Canvas[id.xy] = curBrush;
}