#pragma kernel Update
#pragma kernel InitBackground

RWTexture2D<float4> _Canvas;
float _CanvasWidth;
float _CanvasHeight;
float4 _PreviousMousePosition;
float4 _MousePosition;
float _StrokeSmoothingInterval;
bool _MouseDown;
float _BrushSize;
float4 _BrushColour;
float4 _BackgroundColour;

float4 SoftBrush(float2 pixelPos, float4 currentColor, float4 brushColor, float brushSize, float2 previousMousePosition,
	float2 mousePosition, float strokeSmoothingInterval)
{
	for (float i = 0; i < 1.0; i += strokeSmoothingInterval)
	{
		float4 outputColor = brushColor;
		const float2 mousePos = lerp(previousMousePosition, mousePosition, i);
		// Pixels affected by brush
		// TODO, weird  interpolation bug. un even stamping

		if (length(pixelPos - mousePos) < brushSize) {
			//outputColor.r = lerp(brushColor.r, currentColor.r, brushColor.a);
			//outputColor.g = lerp(brushColor.g, currentColor.g, brushColor.a);
			//outputColor.b = lerp(brushColor.b, currentColor.b, brushColor.a);
			////outputColor.w = (float)((float)length(pixelPos - mousePos) / (float)brushSize);
			outputColor.w = 1.0f; // Solid on purpose, alpha is set later
			//return outputColor;
			return outputColor;
		}
	}
	// Pixels not affected by brush
	return currentColor;
}

[numthreads(8, 8, 1)]
void InitBackground(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= _CanvasWidth || id.y >= _CanvasHeight)
		return;

	_BackgroundColour.w = 0.0f;
	_Canvas[id.xy] = _BackgroundColour;
}

[numthreads(8, 8, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
	if (!_MouseDown)
		return;

	if (id.x >= _CanvasWidth || id.y >= _CanvasHeight)
		return;

	float4 curBrush = SoftBrush(id.xy, _Canvas[id.xy], _BrushColour, _BrushSize,
		_PreviousMousePosition, _MousePosition, _StrokeSmoothingInterval);
	_Canvas[id.xy] = curBrush;
}